import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from enum import Enum
import pandas as pd

logger = logging.getLogger(__name__)


class PositionSide(Enum):
    LONG = "long"
    SHORT = "short"


class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(Enum):
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: str  # 'entry', 'exit', 'adjustment'
    action: str  # 'buy', 'sell', 'hold'
    confidence: float  # 0-100
    quantity: Optional[float] = None
    price: Optional[float] = None
    order_type: OrderType = OrderType.MARKET
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyPosition:
    """Position managed by a strategy."""
    strategy_name: str
    symbol: str
    side: PositionSide
    quantity: float
    entry_price: float
    current_price: float
    entry_time: datetime
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    max_loss: Optional[float] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
    
    @property
    def market_value(self) -> float:
        """Current market value of the position."""
        return self.quantity * self.current_price
    
    @property
    def unrealized_pnl(self) -> float:
        """Unrealized P&L of the position."""
        if self.side == PositionSide.LONG:
            return (self.current_price - self.entry_price) * self.quantity
        else:
            return (self.entry_price - self.current_price) * self.quantity
    
    @property
    def unrealized_pnl_pct(self) -> float:
        """Unrealized P&L as percentage."""
        cost_basis = abs(self.entry_price * self.quantity)
        return (self.unrealized_pnl / cost_basis) * 100 if cost_basis > 0 else 0
    
    def update_price(self, new_price: float):
        """Update current price of the position."""
        self.current_price = new_price
    
    def should_exit_profit(self) -> bool:
        """Check if position should exit due to profit target."""
        if self.take_profit is None:
            return False
        
        if self.side == PositionSide.LONG:
            return self.current_price >= self.take_profit
        else:
            return self.current_price <= self.take_profit
    
    def should_exit_loss(self) -> bool:
        """Check if position should exit due to stop loss."""
        if self.stop_loss is None:
            return False
        
        if self.side == PositionSide.LONG:
            return self.current_price <= self.stop_loss
        else:
            return self.current_price >= self.stop_loss
    
    def should_exit_max_loss(self) -> bool:
        """Check if position should exit due to max loss limit."""
        if self.max_loss is None:
            return False
        
        return self.unrealized_pnl <= -abs(self.max_loss)


class Strategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.enabled = config.get('enabled', True)
        self.positions: Dict[str, StrategyPosition] = {}
        self.signals_history: List[StrategySignal] = []
        self.performance_metrics: Dict[str, float] = {}
        
        logger.info(f"Initialized strategy {name} with config: {config}")
    
    @abstractmethod
    def generate_signals(self, market_data: Dict[str, pd.DataFrame], 
                        current_positions: Dict[str, Any]) -> List[StrategySignal]:
        """Generate trading signals based on market data."""
        pass
    
    @abstractmethod
    def validate_signal(self, signal: StrategySignal, 
                       market_data: Dict[str, Any]) -> bool:
        """Validate a signal before execution."""
        pass
    
    @abstractmethod
    def calculate_position_size(self, signal: StrategySignal, 
                               account_equity: float, 
                               risk_per_trade: float) -> float:
        """Calculate position size for a signal."""
        pass
    
    @abstractmethod
    def should_exit_position(self, position: StrategyPosition, 
                            market_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Determine if a position should be exited."""
        pass
    
    def add_position(self, position: StrategyPosition):
        """Add a position to the strategy."""
        self.positions[position.symbol] = position
        logger.info(f"Added position for {position.symbol}: {position.side.value} {position.quantity}")
    
    def remove_position(self, symbol: str) -> Optional[StrategyPosition]:
        """Remove a position from the strategy."""
        position = self.positions.pop(symbol, None)
        if position:
            logger.info(f"Removed position for {symbol}")
        return position
    
    def update_position_prices(self, price_data: Dict[str, float]):
        """Update current prices for all positions."""
        for symbol, position in self.positions.items():
            if symbol in price_data:
                position.update_price(price_data[symbol])
    
    def get_active_positions(self) -> List[StrategyPosition]:
        """Get all active positions."""
        return list(self.positions.values())
    
    def get_position(self, symbol: str) -> Optional[StrategyPosition]:
        """Get position for a specific symbol."""
        return self.positions.get(symbol)
    
    def has_position(self, symbol: str) -> bool:
        """Check if strategy has a position in symbol."""
        return symbol in self.positions
    
    def calculate_total_exposure(self) -> float:
        """Calculate total market exposure."""
        return sum(abs(pos.market_value) for pos in self.positions.values())
    
    def calculate_unrealized_pnl(self) -> float:
        """Calculate total unrealized P&L."""
        return sum(pos.unrealized_pnl for pos in self.positions.values())
    
    def add_signal(self, signal: StrategySignal):
        """Add signal to history."""
        self.signals_history.append(signal)
        
        # Keep only last 1000 signals to prevent memory issues
        if len(self.signals_history) > 1000:
            self.signals_history = self.signals_history[-1000:]
    
    def get_recent_signals(self, hours: int = 24) -> List[StrategySignal]:
        """Get signals from the last N hours."""
        cutoff = datetime.now() - timedelta(hours=hours)
        return [s for s in self.signals_history if s.timestamp >= cutoff]
    
    def update_performance_metrics(self, metrics: Dict[str, float]):
        """Update strategy performance metrics."""
        self.performance_metrics.update(metrics)
    
    def get_status(self) -> Dict[str, Any]:
        """Get current strategy status."""
        return {
            'name': self.name,
            'enabled': self.enabled,
            'active_positions': len(self.positions),
            'total_exposure': self.calculate_total_exposure(),
            'unrealized_pnl': self.calculate_unrealized_pnl(),
            'recent_signals': len(self.get_recent_signals()),
            'performance': self.performance_metrics
        }
    
    def reset(self):
        """Reset strategy state."""
        self.positions.clear()
        self.signals_history.clear()
        self.performance_metrics.clear()
        logger.info(f"Reset strategy {self.name}")
    
    def enable(self):
        """Enable the strategy."""
        self.enabled = True
        logger.info(f"Enabled strategy {self.name}")
    
    def disable(self):
        """Disable the strategy."""
        self.enabled = False
        logger.info(f"Disabled strategy {self.name}")
    
    def validate_universe(self, symbols: List[str]) -> List[str]:
        """Validate and filter trading universe."""
        valid_symbols = []
        universe = self.config.get('universe', [])
        
        for symbol in symbols:
            if symbol in universe:
                valid_symbols.append(symbol)
            else:
                logger.debug(f"Symbol {symbol} not in strategy universe for {self.name}")
        
        return valid_symbols
    
    def check_correlation_limit(self, new_symbol: str, 
                               correlated_symbols: List[str]) -> bool:
        """Check if adding new position would violate correlation limits."""
        correlation_limit = self.config.get('correlation_limit', 1)
        
        # Count current positions in correlated symbols
        current_correlated = sum(1 for sym in correlated_symbols if self.has_position(sym))
        
        # Check if we can add another correlated position
        if new_symbol in correlated_symbols and current_correlated >= correlation_limit:
            logger.warning(f"Correlation limit reached for {self.name}: {current_correlated}/{correlation_limit}")
            return False
        
        return True
    
    def get_risk_metrics(self) -> Dict[str, float]:
        """Calculate risk metrics for the strategy."""
        if not self.positions:
            return {}
        
        total_exposure = self.calculate_total_exposure()
        unrealized_pnl = self.calculate_unrealized_pnl()
        
        # Calculate position-level metrics
        position_count = len(self.positions)
        avg_position_size = total_exposure / position_count if position_count > 0 else 0
        
        # Calculate risk concentration
        largest_position = max((abs(pos.market_value) for pos in self.positions.values()), default=0)
        concentration_ratio = largest_position / total_exposure if total_exposure > 0 else 0
        
        return {
            'total_exposure': total_exposure,
            'unrealized_pnl': unrealized_pnl,
            'position_count': position_count,
            'avg_position_size': avg_position_size,
            'largest_position': largest_position,
            'concentration_ratio': concentration_ratio
        }